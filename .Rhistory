for (j in 1:n){
for (i in 1:m){
if (j %in% segs["start"] | j %in% segs["end"]){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
S <- collapse_segments(test,1)
data(primseg436_sset)
test <- sset
SO <- extract_segments(S)
SO <- extract_segments(test)
SO
test
summary(test)
data(primseg436_sset)
sset
tset
cset
plotSegmentation(tset, cset, segments, cex=.5, lwd=2)
plotSegmentation(tset, cset, sset, cex=.5, lwd=2)
library(ConsSeg)
data(primseg436_sset)
test <- sset
plotSegmentation(tset, cset, test, cex=.5, lwd=2)
SO <- extract_segments(test)
SO
levels(SO$ID)
levels(SO)
SO$ID
levels(SO$ID)
levels(as.factors(SO$ID))
levels(as.factor(SO$ID))
sset
library(ConsSeg)
data(primseg436_sset)
test <- sset
plotSegmentation(tset, cset, test, cex=.5, lwd=2)
SO <- extract_segments(test)
SO
levels(as.factor(SO$type))
rownames(SO) <- SO$type
SO = subset(S$segments, select = c("type","start","end"))
seq <- c(4,4,1,2,4,4,4,2,4,4,3,4,4,2,4,1,4,4,0,0,0,0,0,0,1,2,2,2,4,1,1,1,1,
0,0,1,1,1,1,1,3,3,3,0,3,3,3,3,0,1,3,4,3,2,4,4,1,3)
deq
seq
sset2 <- segmentClusters(seq = seq,
S = "ccls", M = 3, Mn = 3, a = -2,
save.matrix = TRUE, rm.nui= FALSE)
sset2
startlist <= split(SO$start, SO$ID)
startlist <- split(SO$start, SO$ID)
SO
S
data(primseg436_sset)
test <- sset
#we need to transform this into a list of sequences that contains a list of starts,ends per segment of that sequence
SO = subset(S$segments, select = c("ID","type","CL","start","end"))
#we need to transform this into a list of sequences that contains a list of starts,ends per segment of that sequence
SO = subset(test$segments, select = c("ID","type","CL","start","end"))
SO
startlist <- split(SO$start, SO$ID)
startlist
startlist <- split(SO$start, SO$type)
startlist
str(startlist)
length(startlist)
levels(startlist)
levels(as.factor(startlist))
levels(as.factor(startlist$V1))
startlist <- split(SO$start, SO$type)
colnames(startlist) <- paste0(1:ncol(splitted))
colnames(startlist) <- paste0(1:ncol(startlist))
startlist <- split(SO$start, SO$type)
colnames(startlist) <- paste0(1:ncol(startlist))
ncol(startlist)
startlist <- split(SO$start, SO$type)
colnames(startlist) <- paste0(1:length(startlist))
startlist[,1]
startlist <- split(SO$start, SO$type)
startlist
startlist[1,]
startlist[1,1]
startlist[,1][1,]
startlist[E:1_M:150_nui:1]
rownames(startlist)
colnames(startlist)
summary(startlist)
startlist[[]]
startlist[[1]]
startlist[[2]]
returnlist <- c(startlist, endlist)
endlist <- split(SO$end, SO$type)
returnlist <- c(startlist, endlist)
returnlist
returnlist <- list()
returnlist["starts"] <- startlist
startlist <- split(SO$start, SO$type)
names(startlist) <- paste0("start.",1:length(startlist))
startlist
endlist <- split(SO$end, SO$type)
names(endlist) <- paste0("start.",1:length(endlist))
returnlist <- c(startlist, endlist)
returnlist
startlist <- split(SO$start, SO$type)
names(startlist) <- paste0("start.",1:length(startlist))
endlist <- split(SO$end, SO$type)
names(endlist) <- paste0("end.",1:length(endlist))
returnlist <- c(startlist, endlist)
return(returnlist)
segs <- extract_segments(S)
S <- test
segs <- extract_segments(S)
segs
startlist <- split(SO$start, SO$type)
names(startlist) <- paste0("start.",1:length(startlist))
endlist <- split(SO$end, SO$type)
names(endlist) <- paste0("end.",1:length(endlist))
returnlist <- c(startlist, endlist)
seqs <- returnlist
starts <- segs(grep("start"), names(segs))
segs <- returnlist
starts <- segs(grep("start"), names(segs))
starts <- segs[grep("start"), names(segs)]
starts <- segs[grep("start", names(segs))]
ends <- segs[grep("end", names(segs))]
starts
ends
test <- sset
test
str(test)
str(test)
test$N
starts <- segs[grep("start", names(segs))]
ends <- segs[grep("end", names(segs))]
m <- length(segs)
n <- segs$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = segend)
starts
j <- 93
j %in% starts(paste0("start.",2))
j %in% starts(paste0("start.",2))
starts
j %in% starts[paste0("start.",2)]
starts[paste0("start.",2)]
j
j
j <- '93'
j
starts[paste0("start.",2)]
j %in% starts[paste0("start.",2)]
93 %in% starts[paste0("start.",2)]
'93' %in% starts[paste0("start.",2)]
'93' %in% starts[paste0("start.",2)][]
93 %in% starts[paste0("start.",2)][]
starts[paste0("start.",2)][]
any(sapply(starts,function(x) x$start.2=='93'));
any(sapply(starts["start.2"],function(x) x=='93'));
any(sapply(starts["start.2"],function(x) x=='94'));
any(sapply(starts["start.2"],function(x) x=='449'));
SM <- matrix(0, nrow = m, ncol = segend)
for (j in 1:n){
for (i in 1:m){
if (any(sapply(starts[paste0("start.",i)],function(x) x==j)) | any(sapply(starts[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
m <- length(segs)
n <- segs$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = segend)
for (j in 1:n){
for (i in 1:m){
if (any(sapply(starts[paste0("start.",i)],function(x) x==j)) | any(sapply(starts[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
n
m
segs <- extract_segments(S)
m <- length(segs)
n <- segs$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = segend)
for (j in 1:n){
for (i in 1:m){
if (any(sapply(starts[paste0("start.",i)],function(x) x==j)) | any(sapply(starts[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
n
m
segs
length(segs)
S
data(primseg436_sset)
test <- sset
plotSegmentation(tset, cset, test, cex=.5, lwd=2)
SO <- extract_segments(test)
SO
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset,1)
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Extract starts and end of segments
SO <- extract_segments(sset)
#Create segment matrix for dyn-prog approach
S <- matrixfy_segments(sset,1)
SO
segs <- extract_segments(SO)
#Extract starts and end of segments
segs <- extract_segments(sset)
starts <- segs[grep("start", names(segs))]
ends <- segs[grep("end", names(segs))]
m <- length(segs)
n <- segs$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
m
n
segs
n <- S$N #Total length of input sequences
n
#Load Data
data(primseg436_sset)
library(ConsSeg)
#Extract starts and end of segments
SO <- extract_segments(sset)
#Create segment matrix for dyn-prog approach
S <- matrixfy_segments(sset,1)
###Manual
segs <- extract_segments(sset)
starts <- segs[grep("start", names(segs))]
ends <- segs[grep("end", names(segs))]
m <- length(segs)
n <- S$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if (any(sapply(starts[paste0("start.",i)],function(x) x==j)) | any(sapply(starts[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
j <- 93
any(sapply(starts[paste0("start.",i)],function(x) x==j))
if (any(sapply(starts[paste0("start.",i)],function(x) x==j)) | any(sapply(starts[paste0("end.",i)],function(x) x==j))){}
###Manual
segs <- extract_segments(sset)
m <- length(segs)
n <- S$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if (any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
if (any(sapply(segs[paste0("start.",i)],function(x) x==j)) or any(sapply(segs[paste0("end.",i)],function(x) x==j))){
if (any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j))){
{}
}
if (any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j))){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
for (j in 1:n){
j
}
for (j in 1:n){ print(j)}
for (j in 1:m){ print(j)}
m <- length(segs)/2
n <- S$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/segnr #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
#Create segment matrix for dyn-prog approach
S <- matrixfy_segments(sset,1)
#Load Data
data(primseg436_sset)
#Extract starts and end of segments
SO <- extract_segments(sset)
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Extract starts and end of segments
SO <- extract_segments(sset)
#Create segment matrix for dyn-prog approach
S <- matrixfy_segments(sset,1)
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Extract starts and end of segments
SO <- extract_segments(sset)
#Create segment matrix for dyn-prog approach
S <- matrixfy_segments(sset,1)
S
S[2,93]
S[93,2]
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i,j] = w  # w marks existence of boundary and adds weight of that boundary
}
}
}
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset,1)
summary(SM)
str(SM)
SM <- matrix(0, nrow = m, ncol = n)
m <- length(segs)/2
n <- S$N #Total length of input sequences
###Manual
segs <- extract_segments(sset)
m <- length(segs)/2
n <- S$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/m #For now we only normalize by nr of segments, each segment has same weight
}
w <- 1
if (!is.function(w) & w == 1){
w = 1/m #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
m
n
n <- segs$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/m #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
segs
n <- sset$N #Total length of input sequences
if (!is.function(w) & w == 1){
w = 1/m #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
str(SM)
for (j in 1:n){
for (i in 1:m){
print(SM[i,j])
}
}
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i,j] <- w  # w marks existence of boundary and adds weight of that boundary
}
}
}
str(SM)
summary(SM)
w <- function(x){
x/=10
}
w <- function(x){
x <- x/10
}
if (!is.function(w) & w == 1){
w = 1/m #For now we only normalize by nr of segments, each segment has same weight
}
w <- function(x){
x <- x/10
}
str(w)
is.function(w)
!is.function(w)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, function(x){ x = 1/10})
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, function(x){ x = 1/10; return(x)})
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, function(x){ x = 1/10; return(x)})
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, 1)
summary(SM)
SM
SM[2,]
SM[1,]
str(SM)
SM <- matrix(0, nrow = m, ncol = n)
segs <- extract_segments(sset)
m <- length(segs)/2
n <- S$N #Total length of input sequences
if (!is.function(w)){ #if not function we replace with dummy, assuming a sensible weight functions needs i, j and m for normalization
w <- function(i,j,m){ i=0; j=0; return(1/m)} #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
m
n
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, 1)
str(SM)
head(SM)
head(SM[1,])
head(SM[[1,])
head(SM[[1,]])
SM[[1,]]
SM[[]]
SM[1,[]]
SM[[],[]]
SM
SM[[1000]]
SM[[10]]
SM[[10]][1]
SM[[10]][2]
SM[[10]][3]
SM <- matrix(0, nrow = m, ncol = n)
m <- length(segs)/2
n <- S$N #Total length of input sequences
n<-sset$N
n
SM <- matrix(0, nrow = m, ncol = n)
SM
str(SM)
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i:i,j:j] <- w(i,j,m)  # w marks existence of boundary and adds weight of that boundary
}
}
}
if (!is.function(w)){ #if not function we replace with dummy, assuming a sensible weight functions needs i, j and m for normalization
w <- function(i,j,m){ i=0; j=0; return(1/m)} #For now we only normalize by nr of segments, each segment has same weight
}
SM <- matrix(0, nrow = m, ncol = n)
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i:i,j:j] <- w(i,j,m)  # w marks existence of boundary and adds weight of that boundary
}
}
}
w
w <- function(i,j,m){ i=0; j=0; return(1/m)} #For now we only normalize by nr of segments, each segment has same weight
SM <- matrix(0, nrow = m, ncol = n)
w
for (j in 1:n){
for (i in 1:m){
if ( any(sapply(segs[paste0("start.",i)],function(x) x==j)) | any(sapply(segs[paste0("end.",i)],function(x) x==j)) ){
SM[i:i,j:j] <- w(i,j,m)  # w marks existence of boundary and adds weight of that boundary
}
}
}
str(SM)
summary(SM)
summary(SM)
SM <- matrix(0, nrow = m, ncol = n)
summary(SM)
summary(SM[1,])
summary(SM[1:4,])
library(ConsSeg)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, 1)
colnames(SM)
#Load Data
data(primseg436_sset)
library(ConsSeg)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, 1)
SM
library(ConsSeg)
#Load Data
data(primseg436_sset)
#Create segment matrix for dyn-prog approach
SM <- matrixfy_segments(sset, 1)
SM
SM$segs
