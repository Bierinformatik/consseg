library(ConsSeg)
library(segmenTier)
data(primseg436) # RNA-seq time-series data
# Fourier-transform and cluster time-series:
tset <- processTimeseries(ts=tsd, na2zero=TRUE, use.fft=TRUE,
dft.range=1:7, dc.trafo="ash", use.snr=TRUE)
cset <- clusterTimeseries(tset, K=12)
segments <- segmentClusters(seq=cset, M=100, E=2, nui=3, S="icor")
plotSegmentation(tset, cset, segments, cex=.5, lwd=2)
head(segments)
str(segments)
segments$segments
segs = segments$segments
segs
### DYNAMIC PROGRAMMING BASED SEGMENTATION OF A CLUSTERING
### implemented by Rainer Machne, hopefully
### as conceived by Peter F. Stadler
data(primseq436)
data(primseg436)
trafo <- "raw"     # transformation of the raw data
use.fft <- TRUE    # cluster discrete Fourier transform of data?
use.snr <- TRUE    # use DFT scaling (SNR is described as
# relative amplitude scaling in Machne&Murray, PLoS ONE 2012)
dft.range <- 1:7   # range of DFT to use for clustering
dc.trafo <- "ash"  # transformation of the first (DC) component of the DFT
# NOTE: add component 1 (DC) to DFT range to use
low.thresh <- -Inf # minimal total signal (DC component of DFT if use.fft)
### CLUSTERING PARAMETERS
K <- c(12)         # cluster number K; multiple allowed; specifically, note
# that k-means has a random effect at initialization
# and replicates of the same K can  yield different
# results for otherwise
nui.thresh <- 0.6  # threshold of position-cluster correlation below which
# the position will be assigned to the nuisance cluster
## k-means initialization
iter.max <- 100000 # max. iterations in kmeans
nstart <- 100      # number of initial configurations tested in kmeans
### SEGMENTATION PARAMETERS
## segmenTier parameters are handled via the settings function,
## where all parameters can be passed as vectors.
vary <- setVarySettings(
E=c(1,3), # scale exponent of similarity matrices csim
S="icor", # SCORING FUNCTIONS
M=c(150), # scoring function minimal length penalty
Mn=100,   # M for nuisance clusters
nui=c(1,3)#-/+ correlation of nuisance cluster with others and itself
)
## PRE-PROCESS TIME SERIES FOR CLUSTERING
## take DFT and scale amplitudes, and
## select components of DFT
tset <- processTimeseries(ts=tsd, na2zero=TRUE,
trafo=trafo, dc.trafo=dc.trafo,
use.fft=use.fft, dft.range=dft.range,
use.snr=use.snr, low.thresh=low.thresh)
## CLUSTER PRE-PROCESSED TIME SERIES
set.seed(15) # stable kmeans clustering
cset <- clusterTimeseries(tset, K=K, iter.max=iter.max, nstart=nstart,
nui.thresh=nui.thresh)
### CALCULATE SEGMENTS FOR ALL CLUSTERINGS and
### FOR CHOSEN SEGMENTATION PARAMETERS
## NOTE, that the function optionally also stores the
## the scoring and backtracing matrices (see demo/segment_test.R)
sset <- segmentCluster.batch(cset, varySettings=vary,
id="mysegments",
type.name=c("E","M","nui"), # segment type names
verb=1, save.matrix=FALSE)
segs = segments$segments
segs
segs = sset$segments
segs
plotSegmentation(tset, cset, sset, cex=.5, lwd=2)
segments$segments
segs = subset(segments$segments, select = c("CL","start","end"))
segs
segs = subset(sset$segments, select = c("CL","start","end"))
segs
segs = subset(segments$segments, select = c("CL","start","end"))[order("start", "end"),]
segs
segs = subset(segments$segments[order("start", "end"),] , select = c("CL","start","end"))
segs = subset(segments$segments[order("start", "end"),] , select = c("CL","start","end"))
segs = subset(segments$segments, select = c("CL","start","end"))
segs = segs[order("start", "end"),]
segs
segs = as.dataframe(subset(segments$segments, select = c("CL","start","end")))[order("start", "end"),]
segs = as.data.frame(subset(segments$segments, select = c("CL","start","end")))[order("start", "end"),]
segs
segs = as.data.frame(subset(sset$segments, select = c("CL","start","end")))[order("start", "end"),]
segs
segs = subset(sset$segments, select = c("CL","start","end")))
segs = subset(sset$segments, select = c("CL","start","end"))
str(segs)
segs[order("start","end")]
segs[order("start","end"),]
segs[,order("start","end")]
segs[order("start","end")]
segs[order("start","end"),]
segs[order("start")]
segs[order("start"),]
segs[,order("start")]
?setorder
segs = setorder(subset(segments$segments, select = c("CL","start","end")), c=("start","end"))
segs = setorder(subset(segments$segments, select = c("CL","start","end")),"start","end")
segs = data.frame::setorder(subset(segments$segments, select = c("CL","start","end")),"start","end")
segs = data.table::setorder(subset(segments$segments, select = c("CL","start","end")),"start","end")
segs = subset(segments$segments, select = c("CL","start","end"))
segs = segs[order(segs[,"start"], segs[,"end"]), ]
segs
segs = subset(sset$segments, select = c("CL","start","end"))
segs = segs[order(segs[,"start"], segs[,"end"]), ]
segs
for (i in segs["start"][0]:segs["end"][-1]){
}
segs
segs["start"]
segs["start"][0]
segs["start"][,0]
segs["start"][0,]
segs[0,"start"]
segs[1,"start"]
segs[-1,"end"]
segs[nrow(segs),"end"]
segs
segs[nrow(segs),"end"]
segs[nrow(segs),"end"]
segs[1,"start"]
segstart = segs[order(segs[,"start"], segs[,"end"]), ][1,"start"]
segstart
segend = segs[order(segs[,"start"], segs[,"end"]), ][nrow(osegs),"end"]
segend = segs[order(segs[,"start"], segs[,"end"]), ][nrow(segs),"end"]
segend
segnr = nrow(segs)
segnr
if (!is.function(w) & w == 1){
w = 1/segnr
}
w = 1
if (!is.function(w) & w == 1){
w = 1/segnr
}
w
SM <- matrix(rep(NA,seglen), nrow = segnr)
seglen = segend-segstart+1
SM <- matrix(rep(NA,seglen), nrow = segnr)
SM <- cbind(matrix(rep(NA,seglen), nrow = segnr, byrow = T), 1:seglen)
SM <- cbind(matrix(rep(NA,segnr), nrow = segnr, byrow = T), 1:seglen)
matrix(rep(NA,segnr), nrow = segnr, byrow = T)
cbind(matrix(rep(health + 1, 4), nrow = 4, byrow = T), 1:4)
cbind(matrix(rep(1, 4), nrow = 4, byrow = T), 1:4)
SM <- cbind(matrix(rep(NA,segnr), nrow = segnr, byrow = T), seglen)
SM
SM <- matrix(rep(NA,segnr), nrow = segnr, ncol = seglen, byrow = T)
SM
?matrix
SM <- matrix(nrow = segnr, ncol = seglen)
SM
SM[,1]
SM[1,]
SM <- matrix(0,nrow = segnr, ncol = seglen)
SM[,1]
SM[1,]
